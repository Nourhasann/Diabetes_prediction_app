# -*- coding: utf-8 -*-
"""Copy of Diabetes prediction.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1YRTQ6-ID-immIEg-YY5UYYbAUzUOaIPX

# ***Exploring*** ***Dataset***
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

df = pd.read_csv("/content/diabetes.csv")
df

df.shape
#768->rows
#9->columns

df.columns

df.info()

"""**checking for missing values**"""

df.isna().sum()
# there are no missing values

"""**checking for duplicates**"""

df.duplicated().sum()
#there are no duplicates

df.describe()

df['Outcome'].value_counts()
# 500 -> non-diabetic
# 268 -> diabetic

df.groupby('Outcome').mean()
# get average for values for each outcome

sns.countplot(x='Outcome', data=df)
plt.title('Diabetic"1" vs Non-Diabetic"0"')
plt.show()

#get no of outliers
numerical_cols = df.select_dtypes(include=[np.number]).columns.tolist()
for col in numerical_cols:
    Q1 = df[col].quantile(0.25)
    Q3 = df[col].quantile(0.75)
    IQR = Q3 - Q1
    lower = Q1 - 1.5 * IQR
    upper = Q3 + 1.5 * IQR
    outliers = df[(df[col] < lower) | (df[col] > upper)]
    print(f'{col}: {len(outliers)} outliers')

"""## we aren't getting rid of any outliers because they are important in this medical data

# **Data Visualization**
"""

#no of Diabetic vs non-Diabetic based on no of pregnancies
sns.countplot(data=df, x='Pregnancies', hue='Outcome')

plt.title('Diabetic and Non-Diabetic by Pregnancies number')
plt.xlabel('Pregnancies')
plt.ylabel('Number of Patients')
plt.legend(title='outcome')
plt.show()

plt.figure(figsize=(10,8))
sns.heatmap(df[numerical_cols].corr(),annot=True,cmap='Greys')
plt.show()

for i in range(len(numerical_cols)):
    plt.figure(figsize=(9,4))
    plt.subplot(1, 2, 1)
    sns.histplot(df[numerical_cols[i]],kde=True,color='#8EA7E9')
    plt.xlabel(numerical_cols[i])
    plt.ylabel('Count')
    plt.title(f'Distribution Plot of {numerical_cols[i]}')
    sns.despine()
    plt.subplot(1, 2, 2)
    sns.boxplot(df[numerical_cols[i]],color='#A0C3D2',width=0.6, fliersize=5)
    plt.xlabel(numerical_cols[i])
    plt.ylabel('Count')
    plt.title(f'Distribution Plot of {numerical_cols[i]}')
    sns.despine()
    plt.tight_layout()
plt.tight_layout()
plt.show()

sns.pairplot(df,hue='Outcome')
plt.show()

"""# Standard scaling and label encoding"""

df.head()

x = df.drop('Outcome',axis=1)
y = df['Outcome']

from sklearn.model_selection import train_test_split
x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.2, random_state=42)

print(x_train.shape , x_test.shape)

print(y_train.shape , y_test.shape)

# Scaling Data - Fit on training data and transform both training and testing data
from sklearn.preprocessing import StandardScaler
scaler = StandardScaler()

x_train_scaled = scaler.fit_transform(x_train)
x_test_scaled = scaler.transform(x_test)

x_train_scaled

"""# Training the models

***Logistic Regression***
"""

# logistic regression
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import accuracy_score, classification_report

lr = LogisticRegression()
lr.fit(x_train_scaled, y_train) # Train on scaled data
y_pred = lr.predict(x_test_scaled) # Predict on scaled data

from sklearn.metrics import confusion_matrix
import pandas as pd

cm = confusion_matrix(y_test, y_pred)

cm_df = pd.DataFrame(cm, index=['Actual Non-Diabetic', 'Actual Diabetic'], columns=['Predicted Non-Diabetic', 'Predicted Diabetic'])

print("Confusion Matrix for Logistic Regression:")
print(cm_df)

print("Accuracy:",accuracy_score(y_test, y_pred))
print("Classification Report:\n",classification_report(y_test, y_pred))

"""**Random Forest**"""

from sklearn.ensemble import RandomForestClassifier

rf = RandomForestClassifier(random_state=42)
rf.fit(x_train_scaled, y_train) # Train on scaled data
y_pred_rf = rf.predict(x_test_scaled) # Predict on scaled data

print("Random Forest Accuracy:", accuracy_score(y_test, y_pred_rf))
print("Random Forest Classification Report:\n", classification_report(y_test, y_pred_rf))

from sklearn.metrics import confusion_matrix
import pandas as pd

cm_rf = confusion_matrix(y_test, y_pred_rf)

cm_rf_df = pd.DataFrame(cm_rf, index=['Actual Non-Diabetic', 'Actual Diabetic'], columns=['Predicted Non-Diabetic', 'Predicted Diabetic'])

print("Confusion Matrix for Random Forest:")
print(cm_rf_df)

"""**Support Vector Machine**"""

from sklearn.svm import SVC

svm = SVC(random_state=42)
svm.fit(x_train_scaled, y_train) # Train on scaled data
y_pred_svm = svm.predict(x_test_scaled) # Predict on scaled data

print("SVM Accuracy:", accuracy_score(y_test, y_pred_svm))
print("SVM Classification Report:\n", classification_report(y_test, y_pred_svm))

from sklearn.metrics import confusion_matrix
import pandas as pd

cm_svm = confusion_matrix(y_test, y_pred_svm)

cm_svm_df = pd.DataFrame(cm_svm, index=['Actual Non-Diabetic', 'Actual Diabetic'], columns=['Predicted Non-Diabetic', 'Predicted Diabetic'])

print("Confusion Matrix for Support Vector Machine:")
print(cm_svm_df)

"""**K-Nearest Neighbors**"""

from sklearn.neighbors import KNeighborsClassifier

knn = KNeighborsClassifier()
knn.fit(x_train_scaled, y_train) # Train on scaled data
y_pred_knn = knn.predict(x_test_scaled) # Predict on scaled data

print("KNN Accuracy:", accuracy_score(y_test, y_pred_knn))
print("KNN Classification Report:\n", classification_report(y_test, y_pred_knn))

from sklearn.metrics import confusion_matrix
import pandas as pd

cm_knn = confusion_matrix(y_test, y_pred_knn)

cm_knn_df = pd.DataFrame(cm_knn, index=['Actual Non-Diabetic', 'Actual Diabetic'], columns=['Predicted Non-Diabetic', 'Predicted Diabetic'])

print("Confusion Matrix for K-Nearest Neighbors:")
print(cm_knn_df)

"""**Decision Tree**"""

from sklearn.tree import DecisionTreeClassifier
dt = DecisionTreeClassifier(random_state=42, class_weight='balanced')

dt.fit(x_train_scaled, y_train) # Train on scaled data
y_pred_dt = dt.predict(x_test_scaled) # Predict on scaled data

print("Decision Tree Accuracy:", accuracy_score(y_test, y_pred_dt))
print("Decision Tree Classification Report:\n", classification_report(y_test, y_pred_dt))

from sklearn.metrics import confusion_matrix
import pandas as pd

cm_dt = confusion_matrix(y_test, y_pred_dt)

cm_dt_df = pd.DataFrame(cm_dt, index=['Actual Non-Diabetic', 'Actual Diabetic'], columns=['Predicted Non-Diabetic', 'Predicted Diabetic'])

print("Confusion Matrix for Decision Tree:")
print(cm_dt_df)

"""**Gradient Boosting**"""

from sklearn.ensemble import GradientBoostingClassifier

gb = GradientBoostingClassifier(random_state=42)
gb.fit(x_train_scaled, y_train) # Train on scaled data
y_pred_gb = gb.predict(x_test_scaled) # Predict on scaled data

print("Gradient Boosting Accuracy:", accuracy_score(y_test, y_pred_gb))
print("Gradient Boosting Classification Report:\n", classification_report(y_test, y_pred_gb))

from sklearn.metrics import confusion_matrix
import pandas as pd

cm_gb = confusion_matrix(y_test, y_pred_gb)

cm_gb_df = pd.DataFrame(cm_gb, index=['Actual Non-Diabetic', 'Actual Diabetic'], columns=['Predicted Non-Diabetic', 'Predicted Diabetic'])

print("Confusion Matrix for Gradient Boosting:")
print(cm_gb_df)

input_data = (5,166,72,19,175,25.8,0.587,51)

# Convert to numpy array
input_data_as_numpy_array = np.asarray(input_data)

# Reshape for single sample
input_data_reshaped = input_data_as_numpy_array.reshape(1, -1)

# ðŸ”¹ Scale the input (important!)
input_data_scaled = scaler.transform(input_data_reshaped)

# Predict using the trained Decision Tree model
prediction = dt.predict(input_data_scaled)
print(prediction)

if prediction[0] == 0:
    print('The person is not diabetic')
else:
    print('The person is diabetic')

"""saving the model"""

import pickle

# Save the Decision Tree model
filename = 'decision_tree_model.sav'
pickle.dump(dt, open(filename, 'wb'))

print(f"Decision Tree model saved as {filename}")

#loading the saved model
loaded_model = pickle.load(open('decision_tree_model.sav', 'rb'))

import pickle

# Save the scaler object
filename = 'scaler.sav'
with open(filename, 'wb') as f:
    pickle.dump(scaler, f)

print(f"Scaler object saved as {filename}")